/*
    General Purpose Class Collection (GPCC)

    This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
    If a copy of the MPL was not distributed with this file,
    You can obtain one at https://mozilla.org/MPL/2.0/.

    Copyright (C) 2011 Daniel Jerolm
*/

#include <gpcc/execution/cyclic/TTCEStartStopCtrl.hpp>
#include <gpcc/execution/async/IWorkQueue.hpp>
#include <gpcc/execution/async/WorkPackage.hpp>
#include <gpcc/osal/MutexLocker.hpp>
#include <stdexcept>

namespace gpcc {
namespace execution {
namespace cyclic {

#ifndef __DOXYGEN__
uint8_t const TTCEStartStopCtrl::MaxNbOfLocks;
#endif

/**
 * \brief Constructor.
 *
 * __Exception safety:__\n
 * Strong guarantee.
 *
 * __Thread cancellation safety:__\n
 * Deferred cancellation is safe.
 *
 * ---
 *
 * \param _ttce
 * Reference to the @ref TriggeredThreadedCyclicExec instance which shall be managed by this class.\n
 * __Note:__
 * - The referenced @ref TriggeredThreadedCyclicExec instance must be in state @ref TriggeredThreadedCyclicExec::States::stopped
 *   and no start/stop request must be pending.
 * - The `RequestStartSampling()` and `RequestStopSampling()` methods of the referenced @ref TriggeredThreadedCyclicExec
 *   instance must be called by no others during the life-time of this new @ref TTCEStartStopCtrl instance.
 * - The `OnStateChange()` implementation of the class derived from class @ref TriggeredThreadedCyclicExec must
 *   invoke the @ref OnTTCEStateChange() method of this class.
 * \param _restartAttemptsAfterLossOfLock
 * Number of automatic restarts after the PLL has lost its lock.\n
 * Pass zero to disable this feature.\n
 * This may be changed later via @ref SetRestartAttemptsAfterLossOfLock().
 * \param _wq
 * Pointer to a work queue that shall be used to execute work packages generated by the @ref OnTTCEStateChange()
 * method. The work queue is used to decouple this class' activities from the thread of the managed
 * @ref TriggeredThreadedCyclicExec instance.
 */
TTCEStartStopCtrl::TTCEStartStopCtrl(TriggeredThreadedCyclicExec & _ttce,
                                     uint8_t const _restartAttemptsAfterLossOfLock,
                                     execution::async::IWorkQueue & _wq)
: wq(_wq)
, ttce(_ttce)
, mutex()
, state(States::stopped)
, condVarStateStopped()
, restartAttemptsAfterLossOfLock(_restartAttemptsAfterLossOfLock)
, remainingRestartAttemptsAfterLossOfLock(0)
, nbOfStartLocks(0)
{
  if (ttce.GetCurrentState() != TriggeredThreadedCyclicExec::States::stopped)
    throw std::logic_error("TTCEStartStopCtrl::TTCEStartStopCtrl: _ttce is not in state Stopped");
}

/**
 * \brief Destructor.
 *
 * The object must be in the state @ref States::stopped. \n
 * There must be no start locks.
 *
 * ---
 *
 * __Exception safety:__\n
 * No-throw guarantee.
 *
 * __Thread cancellation safety:__\n
 * Safe, no cancellation point included.
 */
TTCEStartStopCtrl::~TTCEStartStopCtrl(void)
{
  gpcc::osal::MutexLocker mutexLocker(mutex);
  if ((state != States::stopped) || (nbOfStartLocks != 0))
    PANIC();
}

/**
 * \brief Retrieves a textual description for an @ref Result value.
 *
 * __Thread safety:__\n
 * This is thread-safe.
 *
 * __Exception safety:__\n
 * Strong guarantee.
 *
 * __Thread cancellation safety:__\n
 * Safe, no cancellation point included.
 *
 * ---
 *
 * \param code
 * @ref Result value for which a textual description shall be retrieved.
 * \return
 * Pointer to a null-terminated c-string with a textual description of the @ref Result value 'code'.
 */
char const * TTCEStartStopCtrl::Result2String(Result const code)
{
  switch (code)
  {
    case Result::ok:              return "OK";
    case Result::locked:          return "Cannot start, start is locked";
    case Result::alreadyStarted:  return "Cannot start, already starting";
    case Result::alreadyRunning:  return "Cannot start, already running";
    case Result::alreadyStopping: return "Cannot start/stop, already stopping";
    case Result::alreadyStopped:  return "Cannot stop, already stopped";
    default:
      throw std::invalid_argument("TTCEStartStopCtrl::Result2String: Unknown value");
  }
}

/**
 * \brief Locks start of the managed @ref TriggeredThreadedCyclicExec instance.
 *
 * @ref StartAsync() will reject starting the managed @ref TriggeredThreadedCyclicExec instance until
 * @ref UnlockStart() has been called the same number of times as @ref LockStart() has been called.
 *
 * The maximum allowed number of locks is @ref MaxNbOfLocks.
 *
 * ---
 *
 * __Thread safety:__\n
 * This must _not_ be called from:
 * - OnBeforeRestartAfterLossOfLock()
 * - OnStateSwitchedTo_Stopped()
 * - OnStateSwitchedTo_Starting()
 * - OnStateSwitchedTo_Running()
 * - OnStateSwitchedTo_StopPending()
 * - OnStateSwitchedTo_StoppedStopPending()
 * Otherwise this is thread-safe.
 *
 * __Exception safety:__\n
 * Strong guarantee.
 *
 * __Thread cancellation safety:__\n
 * Safe, no cancellation point included.
 */
void TTCEStartStopCtrl::LockStart(void)
{
  osal::MutexLocker mutexLocker(mutex);

  if (nbOfStartLocks == MaxNbOfLocks)
    throw std::logic_error("TTCEStartStopCtrl::LockStart: Maximum number of locks exceeded");

  nbOfStartLocks++;
}

/**
 * \brief Unlocks start of the managed @ref TriggeredThreadedCyclicExec instance.
 *
 * @ref StartAsync() will reject starting the managed @ref TriggeredThreadedCyclicExec instance until
 * @ref UnlockStart() has been called the same number of times as @ref LockStart() has been called.
 *
 * ---
 *
 * __Thread safety:__\n
 * This must _not_ be called from:
 * - OnBeforeRestartAfterLossOfLock()
 * - OnStateSwitchedTo_Stopped()
 * - OnStateSwitchedTo_Starting()
 * - OnStateSwitchedTo_Running()
 * - OnStateSwitchedTo_StopPending()
 * - OnStateSwitchedTo_StoppedStopPending()
 * Otherwise this is thread-safe.
 *
 * __Exception safety:__\n
 * Strong guarantee.
 *
 * __Thread cancellation safety:__\n
 * Safe, no cancellation point included.
 */
void TTCEStartStopCtrl::UnlockStart(void)
{
  osal::MutexLocker mutexLocker(mutex);

  if (nbOfStartLocks == 0)
    throw std::logic_error("TTCEStartStopCtrl::UnlockStart: Not locked");

  nbOfStartLocks--;
}

/**
 * \brief Asynchronously requests start of the managed @ref TriggeredThreadedCyclicExec instance.
 *
 * __Thread safety:__\n
 * This must _not_ be called from:
 * - OnBeforeRestartAfterLossOfLock()
 * - OnStateSwitchedTo_Stopped()
 * - OnStateSwitchedTo_Starting()
 * - OnStateSwitchedTo_Running()
 * - OnStateSwitchedTo_StopPending()
 * - OnStateSwitchedTo_StoppedStopPending()
 * Otherwise this is thread-safe.
 *
 * __Exception safety:__\n
 * Strong guarantee.
 *
 * __Thread cancellation safety:__\n
 * Deferred cancellation is safe.
 *
 * ---
 *
 * \return Result of the operation.
 */
TTCEStartStopCtrl::Result TTCEStartStopCtrl::StartAsync(void)
{
  osal::MutexLocker mutexLocker(mutex);

  if (nbOfStartLocks != 0)
    return Result::locked;

  switch (state)
  {
    case States::stopped:
    {
      ttce.RequestStartSampling(0);

      remainingRestartAttemptsAfterLossOfLock = restartAttemptsAfterLossOfLock;
      state = States::starting;

      try
      {
        OnStateSwitchedTo_Starting();
      }
      catch (std::exception const & e)
      {
        PANIC_E(e);
      }

      return Result::ok;
    }

    case States::starting:
      return Result::alreadyStarted;

    case States::running:
      return Result::alreadyRunning;

    case States::stopPending:
      return Result::alreadyStopping;

    case States::stoppedStopPending:
      return Result::alreadyStopping;
  } // switch (state)

  PANIC();
}

/**
 * \brief Asynchronously requests stop of the managed @ref TriggeredThreadedCyclicExec instance.
 *
 * __Thread safety:__\n
 * This must _not_ be called from:
 * - OnBeforeRestartAfterLossOfLock()
 * - OnStateSwitchedTo_Stopped()
 * - OnStateSwitchedTo_Starting()
 * - OnStateSwitchedTo_Running()
 * - OnStateSwitchedTo_StopPending()
 * - OnStateSwitchedTo_StoppedStopPending()
 * Otherwise this is thread-safe.
 *
 * __Exception safety:__\n
 * Strong guarantee.
 *
 * __Thread cancellation safety:__\n
 * Deferred cancellation is safe.
 *
 * ---
 *
 * \return Result of the operation.
 */
TTCEStartStopCtrl::Result TTCEStartStopCtrl::StopAsync(void)
{
  osal::MutexLocker mutexLocker(mutex);

  switch (state)
  {
    case States::stopped:
      return Result::alreadyStopped;

    case States::starting:
      // intentional fall-through
    case States::running:
    {
      ttce.RequestStopSampling();

      state = States::stopPending;

      try
      {
        OnStateSwitchedTo_StopPending();
      }
      catch (std::exception const & e)
      {
        PANIC_E(e);
      }

      return Result::ok;
    }

    case States::stopPending:
      return Result::alreadyStopping;

    case States::stoppedStopPending:
      return Result::alreadyStopping;
  } // switch (state)

  PANIC();
}

/**
 * \brief Blocks until the @ref TriggeredThreadedCyclicExec instance has stopped and the
 * @ref TTCEStartStopCtrl instance has reached state @ref States::stopped.
 *
 * It is recommended to invoke @ref LockStart() and @ref StopAsync() before calling this.
 * Otherwise a dead-lock will occur if no one else brings the @ref TTCEStartStopCtrl instance
 * into state @ref States::stopped, or if someone restarts the @ref TTCEStartStopCtrl instance
 * _before_ the thread(s) blocked in this is/are scheduled.
 *
 * ---
 *
 * __Thread safety:__\n
 * This must _not_ be called from:
 * - OnBeforeRestartAfterLossOfLock()
 * - OnStateSwitchedTo_Stopped()
 * - OnStateSwitchedTo_Starting()
 * - OnStateSwitchedTo_Running()
 * - OnStateSwitchedTo_StopPending()
 * - OnStateSwitchedTo_StoppedStopPending()
 * - ...the work queue passed to the constructor of this @ref TTCEStartStopCtrl instance.
 * - ...the thread of the @ref TriggeredThreadedCyclicExec instance managed by this.
 * Otherwise this is thread-safe.
 *
 * __Exception safety:__\n
 * Strong guarantee.
 *
 * __Thread cancellation safety:__\n
 * Deferred cancellation is safe.
 */
void TTCEStartStopCtrl::WaitUntilStopped(void) const
{
  osal::MutexLocker mutexLocker(mutex);
  while (state != States::stopped)
    condVarStateStopped.Wait(mutex);
}

/**
 * \brief Sets the initial value of restart attempts after PLL loss of lock.
 *
 * The remaining number of restart attempts after PLL loss of lock is reset to the initial value in two cases:
 * - call to @ref RefreshRemainingStartAttempts()
 * - successful call to @ref StartAsync()
 *
 * ---
 *
 * __Thread safety:__\n
 * This is thread-safe.
 *
 * __Exception safety:__\n
 * Strong guarantee.
 *
 * __Thread cancellation safety:__\n
 * Safe, no cancellation point included.
 *
 * ---
 *
 * \param _restartAttemptsAfterLossOfLock
 * New initial value for the remaining number of restart attempts after PLL loss of lock.\n
 * The remaining number of restart attempts is initialized with this in two cases:
 * - call to @ref RefreshRemainingStartAttempts()
 * - successful call to @ref StartAsync()
 * If the new value shall be applied immediately then @ref RefreshRemainingStartAttempts() must be invoked after this.
 * Pass zero to disable automatic restart after PLL loss of lock.\n
 */
void TTCEStartStopCtrl::SetRestartAttemptsAfterLossOfLock(uint8_t const _restartAttemptsAfterLossOfLock)
{
  osal::MutexLocker mutexLocker(mutex);
  restartAttemptsAfterLossOfLock = _restartAttemptsAfterLossOfLock;
}

/**
 * \brief Refreshes the remaining number of restart attempts after PLL loss of lock.
 *
 * The remaining number of restart attempts is reset to the configured initial value for the number of restart attempts.
 * The initial value is set via the constructor and can be changed via @ref SetRestartAttemptsAfterLossOfLock().
 *
 * Note: Any successful call to @ref StartAsync() also resets the remaining number of restart attempts
 * to the configured initial value.
 *
 * __Thread safety:__\n
 * This must _not_ be called from:
 * - OnBeforeRestartAfterLossOfLock()
 * - OnStateSwitchedTo_Stopped()
 * - OnStateSwitchedTo_Starting()
 * - OnStateSwitchedTo_Running()
 * - OnStateSwitchedTo_StopPending()
 * - OnStateSwitchedTo_StoppedStopPending()
 * Otherwise this is thread-safe.
 *
 * __Exception safety:__\n
 * Strong guarantee.
 *
 * __Thread cancellation safety:__\n
 * Safe, no cancellation point included.
 */
void TTCEStartStopCtrl::RefreshRemainingStartAttempts(void)
{
  osal::MutexLocker mutexLocker(mutex);
  remainingRestartAttemptsAfterLossOfLock = restartAttemptsAfterLossOfLock;
}

/**
 * \brief Retrieves the current state of the @ref TTCEStartStopCtrl.
 *
 * __Thread safety:__\n
 * This must _not_ be called from:
 * - OnBeforeRestartAfterLossOfLock()
 * - OnStateSwitchedTo_Stopped()
 * - OnStateSwitchedTo_Starting()
 * - OnStateSwitchedTo_Running()
 * - OnStateSwitchedTo_StopPending()
 * - OnStateSwitchedTo_StoppedStopPending()
 * Otherwise this is thread-safe.
 *
 * __Exception safety:__\n
 * Strong guarantee.
 *
 * __Thread cancellation safety:__\n
 * Deferred cancellation is safe.
 *
 * ---
 *
 * \return
 * Current state of the @ref TTCEStartStopCtrl.
 */
TTCEStartStopCtrl::States TTCEStartStopCtrl::GetCurrentState(void) const
{
  osal::MutexLocker mutexLocker(mutex);
  return state;
}

/**
 * \brief This must be called from the OnStateChange(...) implementation of the managed
 * @ref TriggeredThreadedCyclicExec instance.
 *
 * For details, please refer to the documentation of @ref TriggeredThreadedCyclicExec::OnStateChange().
 *
 * ---
 *
 * __Thread safety:__\n
 * This is thread-safe.\n
 * This is intended to be invoked in the context of the thread of the managed @ref TriggeredThreadedCyclicExec
 * instance.
 *
 * __Exception safety:__\n
 * No-throw guarantee.
 *
 * __Thread cancellation safety:__\n
 * Deferred cancellation is safe.
 *
 * ---
 *
 * \param newState
 * New state of the managed @ref TriggeredThreadedCyclicExec instance.
 * \param stopReason
 * Reason why the managed @ref TriggeredThreadedCyclicExec instance has stopped.\n
 * If the new state is @ref TriggeredThreadedCyclicExec::States::stopped, then this provides the reason for stopping.\n
 * If the new state is not @ref TriggeredThreadedCyclicExec::States::stopped, then this is always
 * @ref TriggeredThreadedCyclicExec::StopReasons::none.
 */
void TTCEStartStopCtrl::OnTTCEStateChange(TriggeredThreadedCyclicExec::States const newState,
                                          TriggeredThreadedCyclicExec::StopReasons const stopReason)
{
  bool retry = false;
  do
  {
    try
    {
      if (retry)
      {
        OnBadAllocWQ();
        retry = false;
      }

      switch (newState)
      {
        case TriggeredThreadedCyclicExec::States::stopped:
          if (stopReason == TriggeredThreadedCyclicExec::StopReasons::none)
            PANIC(); // Invalid stop reason

          wq.Add(execution::async::WorkPackage::CreateDynamic(this, 0, std::bind(&TTCEStartStopCtrl::OnStop_WQ, this, stopReason)));
          break;

        case TriggeredThreadedCyclicExec::States::starting:
          break;

        case TriggeredThreadedCyclicExec::States::waitLock:
          break;

        case TriggeredThreadedCyclicExec::States::running:
          wq.Add(execution::async::WorkPackage::CreateDynamic(this, 0, std::bind(&TTCEStartStopCtrl::OnRun_WQ, this)));
          break;
      } // switch (newState)
    }
    catch (std::bad_alloc const &)
    {
      retry = true;
    }
    catch (std::exception const & e)
    {
      PANIC_E(e);
    }
  }
  while (retry);
}

/**
 * \brief Internal callback executed in work queue context. Execution is scheduled by @ref OnTTCEStateChange()
 * if the managed @ref TriggeredThreadedCyclicExec instance has entered @ref TriggeredThreadedCyclicExec::States::running.
 *
 * __Thread safety:__\n
 * This is thread-safe.
 *
 * __Exception safety:__\n
 * No-throw guarantee.
 *
 * __Thread cancellation safety:__\n
 * Deferred cancellation is safe.
 *
 */
void TTCEStartStopCtrl::OnRun_WQ(void)
{
  try
  {
    osal::MutexLocker mutexLocker(mutex);

    if (state == States::starting)
    {
      state = States::running;
      OnStateSwitchedTo_Running();
    }
    else if (state != States::stopPending)
    {
      PANIC(); // Unexpected state
    }
  }
  catch (std::exception const & e)
  {
    PANIC_E(e);
  }
}

/**
 * \brief Internal callback executed in work queue context. Execution is scheduled by @ref OnTTCEStateChange()
 * if the managed @ref TriggeredThreadedCyclicExec instance has entered @ref TriggeredThreadedCyclicExec::States::stopped.
 *
 * __Thread safety:__\n
 * This is thread-safe.
 *
 * __Exception safety:__\n
 * No-throw guarantee.
 *
 * __Thread cancellation safety:__\n
 * Deferred cancellation is safe.
 *
 * ---
 *
 * \param stopReason
 * Indicates the reason for entering @ref TriggeredThreadedCyclicExec::States::stopped.
 */
void TTCEStartStopCtrl::OnStop_WQ(TriggeredThreadedCyclicExec::StopReasons const stopReason)
{
  try
  {
    osal::MutexLocker mutexLocker(mutex);

    switch (state)
    {
      case States::stopped:
      {
        PANIC(); // Unexpected state
        break;
      }

      case States::starting:
      {
        if (stopReason != TriggeredThreadedCyclicExec::StopReasons::triggerTimeout)
          PANIC(); // Unexpected stop-reason (Starting)

        state = States::stopped;
        condVarStateStopped.Broadcast();
        OnStateSwitchedTo_Stopped(stopReason);
        break;
      }

      case States::running:
      {
        if (stopReason == TriggeredThreadedCyclicExec::StopReasons::reqStopSampling)
          PANIC(); // Unexpected stop-reason (Running)

        if ((stopReason != TriggeredThreadedCyclicExec::StopReasons::pllLossOfLock) ||
            (remainingRestartAttemptsAfterLossOfLock == 0))
        {
          state = States::stopped;
          condVarStateStopped.Broadcast();
          OnStateSwitchedTo_Stopped(stopReason);
        }
        else
        {
          remainingRestartAttemptsAfterLossOfLock--;

          uint8_t const delay = OnBeforeRestartAfterLossOfLock();
          ttce.RequestStartSampling(delay);

          state = States::starting;
          OnStateSwitchedTo_Starting();
        }
        break;
      }

      case States::stopPending:
      {
        if (stopReason == TriggeredThreadedCyclicExec::StopReasons::reqStopSampling)
        {
          state = States::stopped;
          condVarStateStopped.Broadcast();
          OnStateSwitchedTo_Stopped(stopReason);
        }
        else
        {
          state = States::stoppedStopPending;
          OnStateSwitchedTo_StoppedStopPending(stopReason);
        }
        break;
      }

      case States::stoppedStopPending:
      {
        if (stopReason != TriggeredThreadedCyclicExec::StopReasons::reqStopSampling)
          PANIC(); // Unexpected stop-reason (StoppedStopPending)

        state = States::stopped;
        condVarStateStopped.Broadcast();
        OnStateSwitchedTo_Stopped(stopReason);
        break;
      }
    } // switch (state)
  }
  catch (std::exception const & e)
  {
    PANIC_E(e);
  }
}

} // namespace cyclic
} // namespace execution
} // namespace gpcc
