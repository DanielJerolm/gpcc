/*
    General Purpose Class Collection (GPCC)
    Copyright (C) 2019, 2022 Daniel Jerolm

    This file is part of the General Purpose Class Collection (GPCC).

    The General Purpose Class Collection (GPCC) is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    The General Purpose Class Collection (GPCC) is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>.

                                      ---

    A special exception to the GPL can be applied should you wish to distribute
    a combined work that includes the General Purpose Class Collection (GPCC), without being obliged
    to provide the source code for any proprietary components. See the file
    license_exception.txt for full details of how and when the exception can be applied.
*/

/**
 * \ingroup GPCC
 * \defgroup GRP_GPCC_CODING_STYLE GPCC coding style
 * \brief GPCC coding style guidelines
 *
 * The GPCC coding style is [here](@ref GPCC_CODING_STYLE).
 */

/**
 * \anchor GPCC_CODING_STYLE
 * \page PAGE_GPCC_CODING_STYLE GPCC coding style
 * \tableofcontents
 *
 * This page contains a set of rules and recommendations that shall be obeyed when modfying or extending GPCC code.
 *
 * \section GCS_GR General rules
 * \subsection GCS_GR_LANGUAGE_INDENTION_APPEARANCE Language, indention, code appearance
 * - All comments, doxygen documentation, variable names, class names, and function names shall be written in english
 *   language.
 * - Line length should not exceed 120 characters.\n
 *   Exception: Table-like formatted code, e.g. initialization of a field of structs.
 * - Tabs shall not be used to indent code. Instead code shall be indented by 2 white-spaces per {...} scope.
 *   ~~~{.cpp}
 *   if (valid)
 *   {
 *     DoSomething();
 *   }
 *   ~~~
 * - Declarations/definitions within a namespace are not requried to be indented, if the namespace covers almost the
 *   whole file.
 *   ~~~{.cpp}
 *   namespace gpcc      {
 *   namespace execution {
 *   namespace async     {
 *
 *   // ...
 *
 *   } // namespace async
 *   } // namespace execution
 *   } // namespace gpcc
 *   ~~~
 * - Forward declarations may use indention if readability is increased.
 *
 * \subsection GCS_GR_DIR_AND_FILE_STRUCT Directory and file structure
 * - Class declaration and class definition shall be splitted into an hpp- and a cpp-file.
 * - Private header files shall be located in the same folder as the cpp-file.
 * - Public header files shall be locaded in the include/gpcc-folder. The directory structure below the
 *   include/gpcc-folder and below the src-folder shall match each other.
 *
 * \subsection GCS_GR_CONST_AND_VOLATILE_KEYWORDS const and volatile
 * - `const` and `volatile` keywords shall be written on the right hand of the type specifier:
 *   ~~~{.cpp}
 *   uint32_t const * pData;        // Pointer to constant (read-only) data.
 *   uint32_t * const pData;        // Constant pointer to modifiable (read-write) data.
 *   uint32_t const * const pData;  // Constant pointer to constant data.
 *   ~~~
 *
 * \subsection GCS_GR_NOEXCEPT_KEYWORD noexcept
 * - Any function or method that does not throw (exception safety: "No-throw guarantee") and that does not contain a
 *   cancellation point (thread cancellation safety: "No cancellation point included") shall have the `noexcept`
 *   specifier attached to it.
 *
 * \section GCS_NAMING Naming
 * \subsection GCS_NAMING_DIRS_AND_FILES Directories and files
 * - Directory names shall be comprised of 'a'-'z', '0'-'9', and '_' characters only. "snake_case" is OK.
 * - C++ source files shall have the extension '.cpp', '.hpp', or '.tcc'
 * - If a pair of hpp- and cpp-files contain a single class only, then the cpp- and hpp-file names shall be equal to the
 *   name of the class and use pascal-casing like class names.
 * - If a pair of hpp- and cpp-files does not contain a single class (but multiple classes or just definitions or
 *   functions), then the cpp- and hpp-file names shall be comprised of 'a'-'z', '0'-'9', and '_' characters only and
 *   use snake_case.
 *
 * \subsection GCS_NAMING_NAMESPACES Namespaces
 * - Namespace names shall be comprised of 'a'-'z', '0'-'9', and '_' characters only.
 * - Namespace names shall be short.
 * - GPCC uses namespaces to divide the offered classes, types and functions into meaningful groups. Modern IDEs offer
 *   word completion which allows for easy navigation to a desired class if namespaces are used to group stuff by
 *   topics.
 *
 * \subsection GCS_NAMING_ITEMS Classes, Methods, Attributes, Functions
 * - Class names shall use pascal-casing.
 * - Method names shall use pascal-casing.
 * - Attribute names shall use camel-casing.
 * - Function names shall use pascal-casing.
 * ~~~{.cpp}
 * class QueueEntry
 * {
 *    public:
 *      size_t nbOfElements;
 *      void AddElement(void);
 * }
 *
 * uint32_t CalculateSum(uint32_t firstOperand, uint32_t secondOperand)
 * {
 *   uint32_t i;
 *   uint32_t intermediateResult;
 * }
 * ~~~
 *
 * - Template parameters shall be written in uppercase.
 *   ~~~{.cpp}
 *   template<typename TDATA>
 *   class DemoClass
 *   {
 *     // ..
 *   };
 *   ~~~
 *
 * \subsection GCS_NAMING_PREFIXES Prefixes
 * - Typedefs shall be prefixed with 't':
 *   ~~~{.cpp}
 *   typedef uint32_t tIdent;
 *   ~~~
 * - Pointers shall be prefixed with 'p' or 'pp'.
 * - Smart pointers shall be prefixed with 'sp'.
 * - Classes that define an abstract interface shall be prefixed with 'I'.
 *
 * \section GCS_UNIT_TESTS Unit tests with googletest
 * GPCC uses the googletest framework to build its unit tests.
 *
 * googletest identifies test cases by two strings:
 * - test suite name / test fixture name
 *
 * plus
 *
 * - test name
 *
 * \subsection GCS_UNIT_TESTS_DIRECTORY_STRUCTURE Directory structure
 * Unit tests shall be located under gpcc/test_src/...\n
 * The directory structure below "gpcc/test_src" shall correspond to "gpcc/src".
 *
 * \subsection GCS_UNIT_TESTS_FILENAMES File Names
 * The names of the files containing unit tests for a specific class or module shall be derived from the name of the
 * source file containing the UUT plus the prefix "Test".
 *
 * Example:\n
 * Source files: gpcc/src/execution/async/WorkPackage.cpp/.hpp\n
 * Unit tests: gpcc/test_src/execution/async/TestWorkPackage.cpp
 *
 * \subsection GCS_UNIT_TESTS_TESTSUITE_NAMING Test suite naming
 * The _test suite name_ shall be comprised of the namespace in which the UUT is located plus the UUT's name plus the
 * postfix "_Tests" or "_DeathTests".\n
 * In case of a test fixture, the postfix "_TestsF" or "_DeathTestsF" shall be used.
 * - In case of a nested namespace, the names of each namespace (from outmost to the inner one) shall be concatenated
 *   using underscores.
 * - In case of the UUT being a class, the class' name shall be appended using an underscore to separate it from the
 *   namespace.
 * - In case of the UUT being not a class, the module's or file's name shall be appended using an underscore to separate
 *   it from the namespace.
 *
 * The _test name_ shall be a description of the scope or content of the test case.
 *
 * Example:
 * ~~~{.cpp}
 * TEST(gpcc_crc_SimpleCRC_Tests, crc16_ccitt_table_normal)
 * //   ^                         ^
 * //   Test suite name           Test case name
 * {
 *   // ...
 * }
 * ~~~
 *
 * For death tests it is not required to define a second test fixture. Instead a typedef can be used:
 * ~~~{.cpp}
 * typedef gpcc_cood_ObjectPtr_TestsF gpcc_cood_ObjectPtr_DeathTestsF;
 * ~~~
 *
 * \subsection GCS_UNIT_TESTS_PARAM_TESTSUITE_NAMING Naming of a test suite based on a parametrized test fixture
 * These type of test is usually used in conjunction with an interface implemented by the UUT. The name of the
 * parametrized test fixture shall be build from the interface's name plus the postfix "_TestsF" or "_DeathTestsF".\n
 * Example:
 * ~~~{.cpp}
 * template <typename T>
 * class IWorkQueue_TestsF: public Test
 * // ...
 * ~~~
 *
 * Googletest limits the number of test cases per parametrized test suite to no more than 50. If the limit is exceeded,
 * then multiple parametrized test fixtures shall be derived from the original test fixture and each shall contain up to
 * 50 test cases. The derived parametrized test fixtures shall be numbered as shown in the example below:
 * ~~~{.cpp}
 * template <typename T>
 * using IWorkQueue_Tests1F = IWorkQueue_TestsF<T>;
 *
 * template <typename T>
 * using IWorkQueue_Tests2F = IWorkQueue_TestsF<T>;
 *
 * template <typename T>
 * using IWorkQueue_DeathTests1F = IWorkQueue_TestsF<T>;
 * ~~~
 *
 * Upon instantiation of the typed tests via `INSTANTIATE_TYPED_TEST_SUITE_P`, a _Prefix_, a _SuiteName_, and a type or
 * a list of types (_Types_) shall be specified:\n
 * The _Prefix_ shall be the namespace and the name of the UUT concatenated using underscores.\n
 * The _SuiteName_ must correspond to the parametrized test fixture.\n
 * The _Types_ field shall contain one type only: The UUT.\n
 * Example:
 * ~~~{.cpp}
 * INSTANTIATE_TYPED_TEST_SUITE_P(gpcc_execution_async_WorkQueue_, IWorkQueue_Tests1F, WorkQueue);
 * //                             ^                                ^                   ^
 * //                             Prefix                           Test fixture of     Type of UUT the test shall be
 * //                                                              parametrized test   applied to.
 * //                                                              suite.
 * ~~~
 *
 * An example for creation of a parametrized test fixture (with more than 50 tests) is here:
 * - gpcc/test_src/execution/async/TestIWorkQueue.hpp
 * - gpcc/test_src/execution/async/TestWorkQueue.cpp
 * - gpcc/test_src/execution/async/TestDeferredWorkQueue.cpp
 *
 * \subsection GCS_UNIT_TESTS_MACHINE_PERF Tests that depend on machine performance
 * Sometimes it is inevitable that UUTs implement some kind of timing behaviour and that we want to test that behaviour.
 * The results of unit tests that check a UUTs timing behavior will depend directly or indirectly on the performance
 * of the machine executing the tests. This dependency may cause tests to fail on heavy-loaded machines. GPCC provides
 * an OSAL implementation which offers [GPCC's TFC feature](@ref GPCC_TIME_FLOW_CONTROL) to address that issue.
 * [TFC](@ref GPCC_TIME_FLOW_CONTROL) eliminates any CPU load dependency for most types of unit tests.
 *
 * However, [TFC](@ref GPCC_TIME_FLOW_CONTROL) cannot be applied to all tests. GPCC suggests to categorize unit tests
 * into the following three groups. For some groups, preprocessor switches are provided to disable tests in the few
 * cases where the load dependency cannot be solved.
 *
 * __Group 1: Tests that are completely independent of machine performance.__\n
 * These are typically unit tests for passive classes like data containers etc. which do not have an own execution
 * context. These tests usually do not contain any sleeps or timeouts. To some extend these group also includes unit
 * tests for active components incorporating multiple threads, if neither the UUT nor the unit test code relies on any
 * sleeps, timeouts or time-dependent behavior. These tests can be build with or without
 * [TFC](@ref GPCC_TIME_FLOW_CONTROL) and results are always reproducable.
 *
 * __Group 2: Tests for UUTs with timing behavior.__\n
 * This group contains tests for UUTs that have a timing behavior. Typical examples for such UUTs are classes that
 * interact with hardware, or with human beings, or with real-world production processes, or with other software
 * processes or with other devices across a communication network. These kind of UUTs often implement sleeps, timeouts
 * and time-based retry mechanisms.
 *
 * If a GPCC OSAL implementation with [GPCC's TFC feature](@ref GPCC_TIME_FLOW_CONTROL) is used to build the unit tests,
 * then any test in this category will achieve reproducible results on different machines and any load condition.
 *
 * Without TFC, these tests will likely succeed on light-loaded machines if proper tolerance has been designed into the
 * tests. However, these tests may fail on heavy loaded machines if they are not compiled in conjunction with TFC. To
 * avoid false errors if TFC is not used, the switch `SKIP_TFC_BASED_TESTS` may be defined in the build process. If
 * defined, then all tests that require TFC for reproducable results will be excluded from the build.\n
 * Example for appliance of the switch:
 * ~~~{.cpp}
 * #ifndef SKIP_TFC_BASED_TESTS
 * TEST_F(gpcc_example_ClassXY_TestsF, ThreadOrder)
 * {
 *   // ...
 * }
 * #endif
 * ~~~
 *
 * The definition of this switch should rarely be necessary, because TFC should be used in any unit test.
 *
 * __Group 3: Tests for OSAL functions__\n
 * This group contains tests which check the behaviour of OSAL primitives and similar low-level functionality. Usually
 * these tests check the UUT's behaviour very deeply. They e.g. need to measure execution time in order to check
 * presence of sleeps and proper scheduling in the UUT. A few of these tests also need to implement sleeps in order to
 * ensure that some threads in the test fixture or in the UUT have proceeded to some point before the test case
 * continues.
 *
 * Tests in this group cannot benefit from [GPCC's TFC feature](@ref GPCC_TIME_FLOW_CONTROL), because the UUT is located
 * in software layers below TFC. GPCC contains some tests of this type, but an application using GPCC should rarely ever
 * contain any test case in this category.
 *
 * Tests in this category are likely to fail on heavy loaded machines. To avoid false errors, the switch
 * `SKIP_LOAD_DEPENDENT_TESTS` may be defined. If defined, then all tests which depend on machine performance and that
 * cannot use TFC will be excluded from the build. Example for appliance of the switch:
 * ~~~{.cpp}
 * #ifndef SKIP_LOAD_DEPENDENT_TESTS
 * TEST_F(gpcc_example_ClassXY_TestsF, ThreadOrder)
 * {
 *   // ...
 * }
 * #endif
 * ~~~
 *
 * The switch is intended to be used on build-servers. When using or modifying GPCC of course __all__ unit tests must be
 * executed on a developer machine with zero errors at least once.
 *
 * \subsection GCS_UNIT_TESTS_HUGEMEMTESTS Tests that require a huge amount of memory
 * Some test cases may allocate a very large amount of memory by intention and may crash valgrind/memcheck.
 *
 * To prevent this, any tests likely to fail on valgrind due to this issue can be disabled by defining the switch
 * `SKIP_VERYBIGMEM_TESTS`.\n
 * Example for applicance of the switch:
 * ~~~{.cpp}
 * #ifndef SKIP_VERYBIGMEM_TESTS
 * TEST_F(gpcc_example_ClassXY_TestsF, BigData)
 * {
 * // ...
 * }
 * #endif
 * ~~~
 *
 * \subsection GCS_UNIT_TESTS_PERMISSIONS Tests depending on user permissions
 * Some tests require special permissions assigned to the user who executes the tests. This e.g. applies to (but not
 * limited to) tests related to thread scheduling policies.
 *
 * To prevent test failure, test cases which require special user rights can be disabled by defining the switch
 * `SKIP_SPECIAL_RIGHTS_BASED_TESTS`.\n
 * Example for appliance of the switch:
 * ~~~{.cpp}
 * #ifndef SKIP_SPECIAL_RIGHTS_BASED_TESTS
 * TEST_F(gpcc_example_ClassXY_TestsF, BigData)
 * {
 * // ...
 * }
 * #endif
 * ~~~
 *
 * \section GCS_CS Code structure
 * \subsection GCS_CS_CLASS_DECL Class declarations
 * - The visibility compartments inside a class declaration shall be ordered as following:
 *   1. public
 *   2. protected
 *   3. private
 * - Within each visibility compartment, the declared elements shall have the following order:
 *   1. definitions and typedefs
 *   2. constants and attributes (incl. parts)
 *   3. constructors
 *      + default
 *      + with parameters
 *      + copy
 *      + move
 *   4. destructor
 *   5. static methods
 *   6. operators
 *   7. methods
 * - A class must either be declared `final` or it must have a virtual destructor.\n
 *   From technical point of view a virtual destructor is only required in the very base class, but for simplicity
 *   any class shall either be final or have a virtual destructor.
 * - The following methods must be explicitly declared and either an implementation must be provided or a default
 *   implementation must be choosen (`= default`), or the method must be explicitly deleted (`= delete`):
 *   + standard constructor
 *   + copy-constructor
 *   + move-constructor
 *   + copy-assignment operator
 *   + move-assignment operator
 *
 * ~~~{.cpp}
 * class Example final
 * {
 *   public:
 *     enum class Modes
 *     {
 *       ModeA,
 *       ModeB
 *     };
 *
 *     typedef uint32_t tMyType;
 *
 *     static constexpr uint32_t specialKey = 0x12345678UL;
 *
 *     uint32_t varAB;
 *     uint32_t varXY;
 *
 *     Example(void);
 *     explicit Example(uint32_t p);
 *     Example(uint32_t p1, uint32_t p2);
 *     Example(Example const &);
 *     Example(Example &&);
 *     ~Example(void);
 *
 *     static Example* CreateSpecialInstance(void);
 *
 *     Example& operator=(Example const &);
 *     Example& operator=(Example &&);
 *
 *     void Method1(void);
 *     void Method2(void);
 *
 *   protected:
 *     // same structure as "public"
 *
 *   private:
 *     // same structure as "public"
 * };
 * ~~~
 *
 * \subsection GCS_CS_INLINES_METHODS Inlined methods
 * - Inlined methods shall be defined in the header file after the class declaration.
 * - Inlined methods need a full doxygen documentation.
 *
 * \subsection GCS_CS_HEADER_FILES Header files
 * \subsubsection GCS_CS_HEADER_FILES_INCLUDE_GUARDS Include Guards
 * Header files shall use an include guard. The include guard shall be comprised of the file name in upper-case
 * characters plus a timestamp. The intention is to create a unique ID. The format of the timestamp shall be:
 * YYYYMMDDHHMM
 *
 * ~~~{.cpp}
 * #ifndef MYHEADER_HPP_201612172104
 * #define MYHEADER_HPP_201612172104
 * // ...
 * #endif // MYHEADER_HPP_201612172104
 * ~~~
 *
 * \subsubsection GCS_CS_HEADER_FILES_NESTED_INCLUDES Nested includes in hpp-files
 * - Header files shall include all files required to compile the _header_ file.
 * - Header files shall not include files required to compile a _source_ file that includes the header file. Any extra
 *   headers required by a _source_ file shall be included by the _source_ file.
 * - Required includes (e.g. `cstdint`) shall not be omitted even if another included header file already brings them
 *   in. If in the future the other header file does not need the include any more, then it could be removed and thus
 *   break our header file by accident.
 * - Forward declarations shall be preferred above nested includes whenever possible.
 * - Public headers must not include private headers.
 *
 * \subsubsection GCS_CS_HEADER_FILES_ORDER Order of #include statements
 * - In case of a cpp-file, the own header shall be included first.
 * - In case of a hpp-file, the headers of base classes shall be included first.
 * - The other headers shall be included in the following order:
 *   + Public headers from gpcc in alphabetical order using angle brackets:\n
 *     `#include <gpcc/.../some_file.hpp>`
 *   + Private headers from gpcc in alphabetical order using double qoutes:\n
 *     `#include "src/.../some_file.hpp"`\n
 *     `#include "src_notest/.../some_file.hpp"`\n
 *     `#include "test_src/.../some_file.hpp"`\n
 *   + System headers in alphabetical order using angle brackets:\n
 *     `#include <pthread>`
 *   + STL headers in alphabetical order using angle brackets:\n
 *     `#include <vector>`
 *   + C standard library headers in alphabetical order using angle brackets:\n
 *     `#include <cstdint>`
 * - All required headers shall be included. Do not rely on that an included header brings another header you need.
 *
 * \section GCS_DOC Documentation
 * \subsection GCS_DOC_GENERAL General
 * - The doxygen templates in "gpcc/doxygen_templates.txt" shall be used.
 * - Doxygen command prefix:
 *   + '\\' shall be used for commands that start on a new line like \\param, \\brief, etc.
 *   + '@' shall be used for commands that are embedded in the documentation like \@ref
 * - All structs, classes, methods, attributes, functions, types, enums, etc. shall be documented using doxygen.\n
 *   This also applies to private class members, even though they can be excluded from the generated documentation.
 * - Local variables shall not be documented using doxygen.
 * - Unit test source code does not require doxygen documentation.\n
 *   However, it is not forbidden to document unit test related code with doxygen.
 * - Methods shall be defined outside the class declaration. The method's documentation shall be placed directly in
 *   front of the method's definition:
 *   ~~~{.cpp}
 *   // PLACE DOXYGEN DOCUMENTATION HERE
 *   void MyClass::DoSomething(uint32_t arg1)
 *   {
 *     // ...
 *   }
 *   ~~~
 * - Class declarations shall not contain any documentation for methods. The documentation for methods shall be located
 *   directly in front of the definition of the methods.
 * - Class declarations shall contain documentation for attributes and type definitions.
 * - Pure virtual methods shall be documented in the header file which contains the class declaration. The documentation
 *   shall be located outside the class declaration:
 *   ~~~{.cpp}
 *   class C
 *   {
 *     public:
 *       virtual void M(void) = 0;
 *   }
 *
 *   /* <-- in real life, place a second '*' here to make this a doxygen comment
 *    * \fn C::M
 *    * \brief Brief documentation
 *    *
 *    * Details...
 *    */
 *   ~~~
 *
 * \subsection GCS_DOC_THREAD_SAFETY Thread-safety-classification
 * GPCC is designed to be used in a multi-threaded environment.\n
 * Thread-safety specifications are used to provide information to the user how to use a software functionality properly
 * in a multi-threaded environment.\n
 * The following items need a thread-safety specification:
 * - "normal" classes
 * - classes implementing provided interfaces
 * - classes implementing required interfaces
 * - class methods
 * - typedefs for function pointers and function objects (e.g. callbacks)
 * - global and static non-member functions
 *
 * \subsubsection GCS_DOC_THREAD_SAFETY_NORMAL_CLASSES_AND_PROVIDED_ITFS Normal classes and provided interfaces
 * A thread-safety specification shall be included in the documentation of any class and any provided interface. The
 * file "gpcc/doxygen_templates.txt" contains a template for documenting classes and provided interfaces. The template
 * contains predefined specifications for the most frequent use cases:
 *
 * ~~~{.cpp}
 * <Thread-safe.>
 * ~~~
 * The class' implementation contains appropriate locking to properly protect the data of an instance of the class in
 * case of concurrent access by more than one thread.\n
 * There is no difference if the same or different methods of the class are invoked.\n
 * Typical examples for this type of class are:
 * - work queues
 * - message log mechanisms
 *
 * Usually these classes have been intentionally designed for use with multiple threads.
 *
 * ~~~{.cpp}
 * <Not thread safe, but non-modifying concurrent access is safe.>
 * ~~~
 * The class' implementation does not contain any locks. However, multiple threads are allowed to access public methods
 * of the same instance simultaneously, if the invoked methods are const and thus only perform _read-access_ to the
 * instance's data. This is safe, because concurrent _read-access_ does not change the object's state.
 *
 * If a non-const method that might change the object's state shall be invoked, then only one thread is allowed to
 * access the same object at the same time.
 *
 * Users instantiating a class of this type are responsible to ensure that these rules are observed and that proper
 * locking is implemented if necessary. Access to a const object is always safe, because any thread can only invoke
 * const-methods which do not change the object's state.
 *
 * If a const-method wants to modify mutual attributes, then the class has to implement proper locking.
 *
 * \subsubsection GCS_DOC_THREAD_SAFETY_METHODS Methods in normal classes and provided interfaces
 * In addition to the class' thread-safety specification (see above), the documentation of each member function of a
 * class or provided interface shall also contain a thread-safety specification. The file "gpcc/doxygen_templates.txt"
 * contains a template for documenting class methods. The template contains predefined specifications for the most
 * frequent use cases:
 *
 * ~~~{.cpp}
 * <The state of the object is not modified. Concurrent accesses are safe.>
 * ~~~
 * This specification is applicable to classes that have no build-in thread-safety.\n
 * The method performs a read-only access to the object. This means, that the method will not change the state of the
 * accessed object. Concurrent access to this or other read-only methods is safe. Methods with this specification are
 * typically const-methods.\n
 * If mutual attributes are modified, then the class has to implement proper locking.
 *
 * ~~~{.cpp}
 * <The state of the object is modified. Any concurrent accesses are not safe.>
 * ~~~
 * This specification is applicable to classes that have no build-in thread-safety.\n
 * The method performs a read- and/or write-access to the object. This means, that the method may modify the state of
 * the accessed object. Concurrent access to this or any other method of the same object is not allowed. Methods with
 * this specification are always non-const.
 *
 * ~~~{.cpp}
 * <This is thread-safe.>
 * ~~~
 * This specification is applicable to classes with build-in thread-safety.\n
 * The method performs read- and/or write-accesses to the object, but the method implements suitable locking mechanisms
 * to protect the object's data from concurrent access either through this or any other public method offered by the
 * class.
 *
 * \subsubsection GCS_DOC_THREAD_SAFETY_REQUIRED_ITFS Required interfaces
 * A thread-safety specification shall be included in the documentation of any required interface. The file
 * "gpcc/doxygen_templates.txt" contains a template for documenting required interfaces. The template contains
 * predefined specifications for the most frequent use cases.
 *
 * \subsubsection GCS_DOC_THREAD_SAFETY_METHODS_OF_REQUIRED_ITFS Methods of required interfaces
 * In addition to the required interface's thread-safety specification (see above), the documentation of each member
 * function of a required interface shall also contain a thread-safety specification. The file
 * "gpcc/doxygen_templates.txt" contains a template for documenting the methods of a required interface. The template
 * contains predefined specifications for the most frequent use cases. These are the same as for provided interfaces,
 * but the point of view and the wording is reverse: The documentation does not describe a functionality _provided_ to
 * the user, it describes a functionality or behaviour the user is _required_ to provide.
 *
 * \subsubsection GCS_DOC_THREAD_SAFETY_FUNCPTRS Function pointer and function objects (e.g. for callbacks)
 * Any type definition of a function pointer or function object (e.g. `std::function`) shall be documented using the
 * GPCC doxygen templates (gpcc/doxygen_templates.txt). The templates offer predefined specifications documenting the
 * thread-safety, exception-safety, and thread-cancellation-saftey requirements that must be met by the referenced
 * function.
 *
 * \subsubsection GCS_DOC_THREAD_SAFETY_GLOBAL_AND_STATIC_FUNCS Global and static functions and static methods
 * Each global function, each static function, and each static member function shall be documented and the documentation
 * shall contain a thread-safety specification. The GPCC doxygen templates (gpcc/doxygen_templates.txt) for class
 * methods shall be used for non-member functions, too. The templates contain predefined specifications for the most
 * frequent use cases:
 *
 * ~~~{.cpp}
 * <This is thread-safe.>
 * ~~~
 * The function only uses local variables (stored on the stack) and the parameters (if any) passed to the function. If
 * the function accesses any shared resources (e.g. a global variable), then the function implements the required
 * locking.
 *
 * ~~~{.cpp}
 * <This is not thread-safe.>
 * ~~~
 * The function accesses shared resources (e.g. a global variable) and there are no locks implemented in the function.
 * The function must be executed by no more than one thread at any time. The user is responsible to implement sufficient
 * locks to ensure that no more than one thread executes the function at any time.
 *
 * Implementing functions of this type should be avoided.
 *
 * \subsection GCS_DOC_EXCEPTION_SAFETY_ Exception-safety classification
 * GPCC uses exceptions to handle errors. Exception-safety specifications are used to provide information to the user,
 * how a function or method behaves in exceptional situations. The following items require an exception-safety
 * specification:
 * - all methods
 * - global and static functions and static methods
 * - function pointer type definitions
 * - functor/function object type definitions (e.g. typedef to `std::function`)
 *
 * \subsubsection GCS_DOC_EXCEPTION_SAFETY_FUNCTIONS_AND_METHODS Functions and methods
 * Each method and function shall be documented, and the documentation shall contain an exception-safety specification.
 * The GPCC doxygen templates (gpcc/doxygen_templates.txt) provide predefined specifications for the most frequent use
 * cases:
 *
 * ~~~{.cpp}
 * <No-throw guarantee.>
 * ~~~
 * The function will never throw an exception. Operations are guaranteed to succeed and satisfy all requirements even in
 * exceptional situations. If an exception occurs, then it will be handled internally and will not be observed by
 * clients.
 *
 * ~~~{.cpp}
 * <Strong guarantee.>
 * ~~~
 * Operations can fail, but failed operations are guaranteed to have no side effects, so all data retain their original
 * values.
 *
 * ~~~{.cpp}
 * <Basic guarantee:>
 *   <Describe possible side effects here. Preferred format: List of bullet points "- ...">
 * ~~~
 * Partial execution of failed operations can cause side effects, but all invariants are preserved and no resources are
 * leaked. This specification shall be accompanied by a complete list of potential side effects.
 *
 * \subsubsection GCS_DOC_EXCEPTION_SAFETY_FUNCPTRS Function pointer and function object type definitions
 * Any type definition of a functor, function object or function pointer shall be documented using the GPCC doxygen
 * templates (gpcc/doxygen_templates.txt). The templates offer predefined specifications documenting the thread-safety,
 * exception-safety, and thread-cancellation-saftey requirements which must be met by the function referenced by the
 * pointer or function object.
 *
 * \subsection GCS_DOC_THREAD_CANCELLATION_SAFETY Thread cancellation-safety classification
 * Some operating systems and threading APIs (e.g. POSIX threads) offer "deferred cancellation" of threads. After
 * deferred cancellation of a thread has been requested, the thread will continue execution until it hits a so-called
 * "cancellation point".
 *
 * There is a standard set of functions which contain (or may contain) cancellation points. Usually these functions are
 * system calls or blocking functions offered by the system or by the standard C library. For POSIX compliant platforms
 * (e.g. Linux), a list of functions containing cancellation points is located here:\n
 * gpcc/src/osal/cancellation_points.txt
 *
 * Deferred thread cancellation is implemented using a special type of C++ exception which is thrown by a cancellation
 * point if a thread which has a cancellation request pending hits that cancellation point. The special exception type
 * used for thread cancellation is `abi::__forced_unwind` (at least when using gnu/gcc).
 *
 * This special type of exception should not be caught directly. However, if it is caught, then it must be rethrown.
 * A `catch (...)` is sufficient to catch this and any other type of exception. Note that any `catch (...)` block must
 * always contain a rethrow statement (`throw;`). This ensures, that the special exception finally propagates into the
 * thread entry function where it is caught and the thread is properly terminated. Scope-guards, mutex lockers, and RAII
 * objects therefore will work the same way in case of deferred thread cancellation as they do in case of a "normal"
 * exception.
 *
 * If code is written with exception-safety in mind (as it should always be), then handling deferred thread cancellation
 * is not a big challenge. If a thread is cancelled, then the stack will be unwound as if a normal exception had
 * occurred and the thread will terminate with no memory leaks or broken invariants left.
 *
 * However, deferred thread cancellation and exception safety should be treated as separate topics when specifying the
 * behaviour of a function. A function may provide the no-throw-guarantee, though it may contain a thread cancellation
 * point _and thus throw_. Functions containing a cancellation point must not be flagged with the `noexcept` keyword.
 *
 * \subsubsection GCS_DOC_THREAD_CANCELLATION_SAFETY_METHODS_AND_FUNCTIONS Methods and functions
 * All methods and function shall be documented using doxygen and the documentation shall contain a
 * thread-cancellation-safety specification. The GPCC doxygen templates (gpcc/doxygen_templates.txt) provide predefined
 * specifications for the most frequent use cases:
 *
 * ~~~{.cpp}
 * <No cancellation point included.>
 * ~~~
 * The function/method does not contain a cancellation point and the function/method does not invoke any
 * function/method that contains a cancellation point. Thread cancellation will never occur inside this
 * function/method.
 *
 * ~~~{.cpp}
 * <Strong guarantee.>
 * ~~~
 * The function/method may contain a cancellation point or it may invoke a function/method that contains a cancellation
 * point. If thread cancellation occurs, then no resources will be leaked and the program will be in a valid state. The
 * state is equal to the state of the program before the function/method has been invoked. This means that all data
 * retain their original values. This guarantee is equal to the strong-guarantee in terms of exception-safety.
 *
 * ~~~{.cpp}
 * <Basic guarantee:>
 *   <Describe possible side effects here. Preferred format: List of bullet points "- ...">
 * ~~~
 * The function/method may contain a cancellation point or it may invoke a function/method that contains a cancellation
 * point. If thread cancellation occurs, then no resources will be leaked and the program will be in a valid state. The
 * state may be different compared to the state of the program before the function/method was invoked. This predefined
 * specification shall be accompanied by a complete list of side effects that may occur in case of deferred thread
 * cancellation.
 *
 * ~~~{.cpp}
 * <Deferred cancellation is not allowed.>
 * ~~~
 * The function/method may contain a cancellation point or it may invoke a function/method that contains a cancellation
 * point. If thread cancellation occurs, then resources may be leaked or the program may be in an invalid state. The
 * function will abort the program via [Panic()](@ref GPCC_OSAL_PANIC).\n
 * This type of function/method must only be invoked with deferred thread cancellation disabled, or if program logic
 * ensures that deferred cancellation cannot be requested while executing this type of function/method.
 *
 * \subsubsection GCS_DOC_THREAD_CANCELLATION_SAFETY_FUNCPTRS Function pointer and function object type definitions
 * Any type definition of a functor, function object or function pointer shall be documented using the GPCC doxygen
 * templates (gpcc/doxygen_templates.txt). The templates offer predefined specifications documenting the thread-safety,
 * exception-safety, and thread-cancellation-saftey requirements which must be met by the function referenced by the
 * pointer or function object.
 */
