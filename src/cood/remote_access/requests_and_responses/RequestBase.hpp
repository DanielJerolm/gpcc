/*
    General Purpose Class Collection (GPCC)

    This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
    If a copy of the MPL was not distributed with this file,
    You can obtain one at https://mozilla.org/MPL/2.0/.

    Copyright (C) 2021 Daniel Jerolm
*/

#ifndef REQUESTBASE_HPP_202006251835
#define REQUESTBASE_HPP_202006251835

#include "ReturnStackItem.hpp"
#include <gpcc/container/IntrusiveDList.hpp>
#include <limits>
#include <memory>
#include <string>
#include <vector>
#include <cstddef>
#include <cstdint>

namespace gpcc   {
namespace Stream {
  class IStreamReader;
  class IStreamWriter;
}
}

namespace gpcc {
namespace cood {

/**
 * \ingroup GPCC_COOD_REMOTEACCESS_REQRESP
 * \brief Base class for all classes implementing requests for remote access to an @ref ObjectDictionary.
 *
 * # Purpose
 * This is the base class for a set of classes implementing different types of requests for remote access to an
 * @ref ObjectDictionary via an @ref IRemoteObjectDictionaryAccess interface.
 *
 * # Counterpart
 * Class @ref ResponseBase is the counterpart to this. It is the base class for the responses generated by class
 * @ref RemoteAccessServer when a request derived from this class is processed.
 *
 * # Internals
 * ## Stack of ReturnStackItem objects
 * For routing remote access responses from the @ref RemoteAccessServer back to the client, remote access requests and
 * remote access responses have a stack of @ref ReturnStackItem objects. The stack is moved from the request object to
 * the response object when the request is processed and the response object is created.
 *
 * Classes transporting remote access requests from the client to the server can push @ref ReturnStackItem objects on
 * the stack of the request object. Later when the response shall be routed back to the originator of the request,
 * the @ref ReturnStackItem objects can be popped from the stack of the response object.
 *
 * ## Serialization and deserialization
 * Instances of this class can be serialized into an [IStreamWriter](@ref gpcc::Stream::IStreamWriter) via
 * @ref ToBinary(). The size of the serialized data can be determined in advance via @ref GetBinarySize().
 *
 * A remote access object serialized via @ref ToBinary() can be deserialized via @ref FromBinary().
 * @ref FromBinary() creates an instance of a subclass of class @ref RequestBase and initializes it with data from
 * the stream. The type and the content of any deserialized object will be equal to the type and content of the
 * original object.
 *
 * - - -
 *
 * __Thread safety:__\n
 * Not thread safe, but non-modifying concurrent access is safe.
 */
class RequestBase
{
  friend class gpcc::container::IntrusiveDList<RequestBase>;

  public:
    /// Remote access request types.
    enum class RequestTypes : uint8_t
    {
      objectEnumRequest = 0U,  ///<Object enumeration request.
      objectInfoRequest = 1U,  ///<Object info request.
      pingRequest       = 2U,  ///<Ping request.
      readRequest       = 3U,  ///<Read request.
      writeRequest      = 4U   ///<Write request.
    };


    /// Minimum useful value for the _maximum permitted size_ of a serialized request (inclusive any
    /// @ref ReturnStackItem objects) accepted by @ref IRemoteObjectDictionaryAccess::Send().
    /** This is also the minimum value of parameter `maxRequestSize` of
        @ref IRemoteObjectDictionaryAccessNotifiable::OnReady(). \n
        See @ref GPCC_COOD_REMOTEACCESS_ITF, chapter "Maximum request/response size" for details. */
    static size_t const minimumUsefulRequestSize = 32U;

    /// Maximum permitted size for a serialized request (inclusive any @ref ReturnStackItem objects)
    /// accepted by @ref IRemoteObjectDictionaryAccess::Send().
    /** This is also the maximum value of parameter `maxRequestSize` of
        @ref IRemoteObjectDictionaryAccessNotifiable::OnReady(). \n
        See @ref GPCC_COOD_REMOTEACCESS_ITF, chapter "Maximum request/response size" for details. */
    static size_t const maxRequestSize = std::numeric_limits<uint32_t>::max();


    RequestBase(void) = delete;
    virtual ~RequestBase(void);

    // serialization/deserialization
    static std::unique_ptr<RequestBase> FromBinary(gpcc::Stream::IStreamReader & sr);
    virtual size_t GetBinarySize(void) const;
    virtual void ToBinary(gpcc::Stream::IStreamWriter & sw) const;

    // return stack
    void Push(ReturnStackItem const & rsi);
    void UndoPush(void);
    void ExtractReturnStack(std::vector<ReturnStackItem> & dest) noexcept;
    size_t GetReturnStackSize(void) const noexcept;

    // miscellaneous
    RequestTypes GetType(void) const noexcept;
    size_t GetMaxResponseSize(void) const;
    virtual std::string ToString(void) const = 0;

  protected:
    /// Latest version of binary data supported by this class and its sub-classes.
    /** @ref ToBinary() will generate a binary with this version.\n
        @ref FromBinary() will accept this version and potential older versions, too. */
    static uint8_t const version = 1U;

    /// Binary size (in byte) of a serialized @ref RequestBase object (excl. `returnStack` and derived class(es)).
    static size_t const baseBinarySize = 7U;


    /// Type of request. Indicates the type of sub-class.
    RequestTypes const type;


    RequestBase(RequestTypes const _type, size_t const _maxResponseSize);
    RequestBase(RequestTypes const _type, gpcc::Stream::IStreamReader & sr, uint8_t const versionOnHand);

    RequestBase(RequestBase const & other);
    RequestBase(RequestBase && other) noexcept;

    RequestBase& operator=(RequestBase const & rhv);
    RequestBase& operator=(RequestBase && rhv);

  private:
    /// Prev-pointer used to enqueue instances of this class in a IntrusiveDList<RequestBase>.
    RequestBase* pPrevInIntrusiveDList;

    /// Next-pointer used to enqueue instances of this class in a IntrusiveDList<RequestBase>.
    RequestBase* pNextInIntrusiveDList;

    /// Maximum response size (in byte) that can be processed by the originator of this request and/or any component
    /// connected in between.
    /** The value refers to a serialized response object and includes any @ref ReturnStackItem objects contained in
        the response object. */
    size_t maxResponseSize;

    /// Stack of information required to route the response back to the originator of the request.
    std::vector<ReturnStackItem> returnStack;


    static RequestTypes ToRequestType(uint8_t const value);
};

/**
 * \brief Retrieves the type of request.
 *
 * - - -
 *
 * __Thread safety:__\n
 * The state of the object is not modified. Concurrent accesses are safe.
 *
 * __Exception safety:__\n
 * No-throw guarantee.
 *
 * __Thread cancellation safety:__\n
 * No cancellation point included.
 *
 * - - -
 *
 * \return
 * Type of request.
 */
inline RequestBase::RequestTypes RequestBase::GetType(void) const noexcept
{
  return type;
}

/**
 * \brief Retrieves the maximum size for the response object that can be processed by the originator of this request
 *        and/or any components connected in between.
 *
 * - - -
 *
 * __Thread safety:__\n
 * The state of the object is not modified. Concurrent accesses are safe.
 *
 * __Thread cancellation safety:__\n
 * No cancellation point included.
 *
 * - - -
 *
 * \return
 * Maximum response size (in byte) that can be processed by the originator of this request and/or any component
 * connected in between.\n
 * The value refers to a serialized response object and includes any @ref ReturnStackItem objects contained in the
 * response object.
 */
inline size_t RequestBase::GetMaxResponseSize(void) const
{
  return maxResponseSize;
}

/**
 * \fn RequestBase::ToString
 * \brief Creates a human-readable text-representation of the remote access request.
 *
 * - - -
 *
 * __Thread safety:__\n
 * The state of the object is not modified. Concurrent accesses are safe.
 *
 * __Exception safety:__\n
 * Strong guarantee.
 *
 * \throws std::bad_alloc   Out of memory.
 *
 * __Thread cancellation safety:__\n
 * No cancellation point included.
 *
 * - - -
 *
 * \return
 * Human-readable text-representation of the remote access request object.\n
 * The output may be comprised of multiple lines separated by '\\n'.\n
 * There is no trailing '\\n'.
 */

} // namespace cood
} // namespace gpcc

#endif // REQUESTBASE_HPP_202006251835